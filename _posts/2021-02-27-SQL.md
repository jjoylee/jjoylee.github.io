---
layout: post
title: DB와 SQL에 대해 정리
tags: [Book]
---

#### DB 메모리 영역
* * *
데이터 캐시 : 자주 조회되는 데이터를 미리 메모리에 올림. 캐시에 있는 데이터를 조회할 떄 속도가 빠르다.  
로그 버퍼 : SQL 구문 > 로그 버퍼에 변경 정보 보냄 > 디스크 변경 수행(로그파일)  
워킹 메모리 : 정렬 또는 해시 관련 처리에 사용되는 작업용 영역  

#### 데이터에 접근하는 방법
* * *

1. 파서 : 구문 분석
2. 옵티마이저 : 선택 가능한 실행계획 작성, 비용 연산, 가장 낮은 비용을 가진 실행계획 선택
3. 카탈로그 매니저 : 테이블 또는 인덱스 통계 정보 저장
4. 플랜평가 : 최적의 실행 결과 선택

#### 실행계획
* * *

1. 테이블 풀 스캔 실행 계획 : 테이블의 데이터 전체를 읽어낸다.
2. 인덱스 스캔 : 인덱스를 사용해서 스캔을 수행
3. 테이블 결합
    - Nested Loops : 한쪽 테이블을 읽으면서 레코드 하나마다 결합 조건에 맞는 레코드를 다른 쪽 테이블에서 찾는다.
    - Sort Merge : 결합키로 레코드를 정렬하고 순차적으로 두 개의 테이블 결합
    - Hash : 결합 키값을 해시값으로 매핑하는 방법

#### 결합 알고리즘
* * *

Nested Loops
- 결합 대상 테이블을 반복해서 스캔. 다른 테이블을 스캔해서 결합조건에 맞으면 리턴
- 결합 대상 레코드를 R(A), R(B)라고 하면 접근되는 레코드 수는 R(A) * R(B)
- 실행시간은 레코드 수에 비례
- Hash 또는 Sort Merge에 비해 메모리 소비가 적다.
- 구동 테이블의 레코드 한 개에 내부 테이블의 레코드 한개가 대응하고, 해당 레코드를 내부 테이블의 인덱스를 사용해 찾을 수 있는 경우 가장 이상적이다.


Hash
- 작은 테이블을 스캔하고, 결합 키에 해시 함수를 적용해서 해시값으로 변환
- 다른 테이블을 스캔하고, 결합 키가 해시값에 존재하는지 확인
- 해시 테이블은 Working Memory에 저장되어 작은 테이블에서 만드는 것이 좋다.

Sort Merge
- 결합 대상 테이블들을 가각 결합키로 정렬하고, 일치하는 결합 키를 찾으면 결합한다.

#### 서브쿼리
* * *

서브쿼리의 문제
- 연산비용 추가 (SELECT 구문 실행 비용)
- 데이터 I/O 비용 발생
- 최적화를 받을 수 없다.

### Reference
* * *
책 : SQL 레벨업 (미크 저)